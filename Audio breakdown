import numpy as np
import sounddevice as sd
import soundfile as sf
from scipy.signal import butter, sosfilt
import time

SAMPLE_RATE = 44100
REC_SECONDS = 5.0

NUM_BANDS = 10
F_MIN = 20.0
F_MAX = 16000.0

ENV_LP_HZ = 300.0
CARRIER_TYPE = "noise"  # "noise" or "sine"

DEVICE_INDEX = None  # set to an integer for a specific input device

def band_edges_log(fmin, fmax, n_bands):
    return np.logspace(np.log10(fmin), np.log10(fmax), n_bands + 1)

def bandpass_sos(lo, hi, fs, order=4):
    lo = max(lo, 10.0)
    hi = min(hi, 0.49 * fs)
    return butter(order, [lo, hi], btype="bandpass", fs=fs, output="sos")

def lowpass_sos(cutoff, fs, order=4):
    cutoff = min(cutoff, 0.49 * fs)
    return butter(order, cutoff, btype="lowpass", fs=fs, output="sos")

def normalize_peak(x, target=0.9):
    peak = float(np.max(np.abs(x))) + 1e-12
    return (x / peak) * target

def snr_db_gain_matched(ref, test):
    denom = float(np.dot(test, test)) + 1e-12
    g = float(np.dot(ref, test)) / denom
    test_g = g * test
    err = ref - test_g
    return 10.0 * np.log10((np.mean(ref * ref) + 1e-12) / (np.mean(err * err) + 1e-12))

def record_audio(seconds, fs, device=None):
    x = sd.rec(int(seconds * fs), samplerate=fs, channels=1, dtype="float32", device=device)
    sd.wait()
    return x[:, 0].copy()

def build_band_signals(x, edges, fs):
    out = []
    for i in range(len(edges) - 1):
        sos = bandpass_sos(float(edges[i]), float(edges[i + 1]), fs, order=4)
        out.append(sosfilt(sos, x).astype(np.float32))
    return np.stack(out, axis=0)

def reconstruct_band_sum(band_signals):
    return np.sum(band_signals, axis=0).astype(np.float32)

def reconstruct_envelope(band_signals, edges, fs, env_lp_hz=300.0, carrier_type="noise"):
    n_bands, n = band_signals.shape
    sos_env = lowpass_sos(env_lp_hz, fs, order=4)
    t = np.arange(n, dtype=np.float32) / float(fs)

    y = np.zeros(n, dtype=np.float32)

    for i in range(n_bands):
        band = band_signals[i]
        env = sosfilt(sos_env, np.abs(band)).astype(np.float32)

        if carrier_type == "noise":
            carrier = np.random.randn(n).astype(np.float32)
        else:
            fc = float(np.sqrt(edges[i] * edges[i + 1]))
            carrier = np.sin(2.0 * np.pi * fc * t).astype(np.float32)

        sos_car = bandpass_sos(float(edges[i]), float(edges[i + 1]), fs, order=4)
        carrier_band = sosfilt(sos_car, carrier).astype(np.float32)

        y += env * carrier_band

    return y.astype(np.float32)

def main():
    edges = band_edges_log(F_MIN, F_MAX, NUM_BANDS)

    print("Recording...")
    x = record_audio(REC_SECONDS, SAMPLE_RATE, device=DEVICE_INDEX)

    orig_path = "original.wav"
    sf.write(orig_path, x, SAMPLE_RATE)

    band_signals = build_band_signals(x, edges, SAMPLE_RATE)

    y_band = reconstruct_band_sum(band_signals)
    y_env = reconstruct_envelope(band_signals, edges, SAMPLE_RATE, env_lp_hz=ENV_LP_HZ, carrier_type=CARRIER_TYPE)

    snr_band = snr_db_gain_matched(x, y_band)
    snr_env = snr_db_gain_matched(x, y_env)

    y_band_play = normalize_peak(y_band, 0.9)
    y_env_play = normalize_peak(y_env, 0.9)
    x_play = normalize_peak(x, 0.9)

    band_path = "reconstructed_band_sum.wav"
    env_path = "reconstructed_envelope.wav"

    sf.write(band_path, y_band_play, SAMPLE_RATE)
    sf.write(env_path, y_env_play, SAMPLE_RATE)

    print(f"SNR vs original (band-sum, gain-matched): {snr_band:.2f} dB")
    print(f"SNR vs original (envelope, gain-matched):  {snr_env:.2f} dB")
    print(f"Saved: {orig_path}, {band_path}, {env_path}")

    print("\nPlaying ORIGINAL...")
    sd.play(x_play, SAMPLE_RATE)
    sd.wait()
    time.sleep(0.4)

    print("Playing BAND-SUM...")
    sd.play(y_band_play, SAMPLE_RATE)
    sd.wait()
    time.sleep(0.4)

    print("Playing ENVELOPE...")
    sd.play(y_env_play, SAMPLE_RATE)
    sd.wait()

    print("\nDone.")

if __name__ == "__main__":
    main()
